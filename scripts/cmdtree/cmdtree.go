////go:build ignore

// Command cmdtree generates a tree visualization of all Cobra commands.
// Run with: go run scripts/cmdtree/cmdtree.go
// Or with: task cmdtree
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"github.com/inovacc/glix/cmd"
	"github.com/spf13/cobra"
)

const goTemplate = `// Code generated by go generate; DO NOT EDIT.

package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

const commandTree = ` + "`" + `{{.Tree}}` + "`" + `

var cmdtreeCmd = &cobra.Command{
	Use:   "cmdtree",
	Short: "Display command tree visualization",
	Long:  "Display a tree visualization of all available commands with descriptions.",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Print(commandTree)
	},
}

func init() {
	rootCmd.AddCommand(cmdtreeCmd)
}

`

// ASCII tree characters for consistent width across all terminals
const (
	treeMiddle = "+-- "
	treeLast   = "\\-- "
	treeIndent = "|   "
	treeSpace  = "    "
)

var (
	outTree     string
	outGo       string
	showHidden  bool
	includeHelp bool
	maxDescLen  int
	commentCol  int
)

func init() {
	flag.StringVar(&outTree, "out-tree", "", "Write tree output to file (markdown/text)")
	flag.StringVar(&outGo, "out-go", "", "Generate Go file with embedded tree")
	flag.BoolVar(&showHidden, "hidden", false, "Show hidden commands")
	flag.BoolVar(&includeHelp, "include-help", false, "Include help/completion commands")
	flag.IntVar(&maxDescLen, "desc-len", 40, "Maximum description length")
	flag.IntVar(&commentCol, "comment-col", 45, "Column for comments")
}

func main() {
	flag.Parse()

	tree := buildTree(cmd.GetRootCmd())

	// 1️⃣ Write tree output
	if outTree != "" {
		writeFile(outTree, tree)
		_, _ = fmt.Fprintf(os.Stderr, "Tree written to %s\n", outTree)
	} else if outGo == "" {
		fmt.Print(tree)
	}

	// 2️⃣ Generate Go file
	if outGo != "" {
		generateGoFile(outGo, tree)
		_, _ = fmt.Fprintf(os.Stderr, "Go command generated: %s\n", outGo)
	}
}

func buildTree(root *cobra.Command) []byte {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("%s\n", root.Use))
	printCommands(&buf, root.Commands(), "")

	return buf.Bytes()
}

func printCommands(w io.Writer, commands []*cobra.Command, prefix string) {
	var visible []*cobra.Command

	for _, c := range commands {
		if !includeHelp && (c.Name() == "help" || c.Name() == "completion") {
			continue
		}

		if !showHidden && c.Hidden {
			continue
		}

		visible = append(visible, c)
	}

	for i, c := range visible {
		isLast := i == len(visible)-1

		connector := treeMiddle
		if isLast {
			connector = treeLast
		}

		desc := c.Short
		if desc == "" {
			desc = c.Long
		}

		if len(desc) > maxDescLen {
			desc = fmt.Sprintf("%s...", desc[:maxDescLen-3])
		}

		cmdPart := prefix + connector + c.Name()
		padding := commentCol - len(cmdPart)
		if padding < 2 {
			padding = 2
		}

		_, _ = fmt.Fprintf(w, "%s%s# %s\n", cmdPart, strings.Repeat(" ", padding), desc)

		if len(c.Commands()) > 0 {
			newPrefix := prefix + treeIndent
			if isLast {
				newPrefix = prefix + treeSpace
			}

			printCommands(w, c.Commands(), newPrefix)
		}
	}
}

func writeFile(path string, buf []byte) {
	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var tree bytes.Buffer

	tree.WriteString("# Command Tree\n\n```\n")
	tree.Write(buf)

	_, _ = f.WriteString(tree.String())
}

func generateGoFile(path string, buf []byte) {
	var tree bytes.Buffer

	tree.WriteString("# Command Tree\n\n")
	tree.Write(buf)

	tmpl := template.Must(template.New("cmdtree").Parse(goTemplate))

	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if err = tmpl.Execute(f, map[string]string{"Tree": tree.String()}); err != nil {
		panic(err)
	}
}
