////go:build ignore

// Command cmdtree generates documentation and tree visualization of all Cobra commands.
// Run with: go run scripts/cmdtree/cmdtree.go
// Or with: task cmdtree
//
// Usage:
//
//	go run scripts/cmdtree/cmdtree.go                    # Print tree to stdout
//	go run scripts/cmdtree/cmdtree.go -out-docs docs/COMMANDS.md  # Generate full docs
//	go run scripts/cmdtree/cmdtree.go -out-go cmd/cmdtree.go      # Generate Go file
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/inovacc/goshell/cmd"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

const goTemplate = `// Code generated by go generate; DO NOT EDIT.

package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

const commandTree = ` + "`" + `{{.Tree}}` + "`" + `

var cmdtreeCmd = &cobra.Command{
	Use:   "cmdtree",
	Short: "Display command tree visualization",
	Long:  "Display a tree visualization of all available commands with descriptions.",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Print(commandTree)
	},
}

func init() {
	rootCmd.AddCommand(cmdtreeCmd)
}

`

// Command categories for documentation organization
var commandCategories = map[string][]string{
	"Core Commands": {
		"ls", "pwd", "cat", "date", "dirname", "basename", "realpath",
	},
	"File Operations": {
		"cp", "copy", "mv", "move", "rm", "remove", "mkdir", "rmdir",
		"touch", "stat", "ln", "readlink", "chmod", "chown",
	},
	"Text Processing": {
		"grep", "egrep", "fgrep", "head", "tail", "sort", "uniq",
		"wc", "cut", "tr", "nl", "paste", "tac", "column", "fold",
		"join", "sed", "awk",
	},
	"System Information": {
		"env", "whoami", "id", "uname", "uptime", "free", "df", "du",
		"ps", "kill", "time",
	},
	"Flow Control": {
		"xargs", "watch", "yes", "nohup",
	},
	"Archive & Compression": {
		"tar", "zip", "unzip",
	},
	"Hash & Encoding": {
		"hash", "sha256sum", "sha512sum", "md5sum",
		"base64", "base32", "base58",
	},
	"Data Processing": {
		"jq", "yq", "dotenv",
	},
	"Security & Random": {
		"encrypt", "decrypt", "uuid", "random",
	},
	"TUI Pagers": {
		"less", "more",
	},
	"Comparison": {
		"diff",
	},
	"Tooling": {
		"lint", "cmdtree", "version",
	},
}

// Category order for documentation
var categoryOrder = []string{
	"Core Commands",
	"File Operations",
	"Text Processing",
	"System Information",
	"Flow Control",
	"Archive & Compression",
	"Hash & Encoding",
	"Data Processing",
	"Security & Random",
	"TUI Pagers",
	"Comparison",
	"Tooling",
}

// ASCII tree characters for consistent width across all terminals
const (
	treeMiddle = "+-- "
	treeLast   = "\\-- "
	treeIndent = "|   "
	treeSpace  = "    "
)

var (
	outTree     string
	outGo       string
	outDocs     string
	showHidden  bool
	includeHelp bool
	maxDescLen  int
	commentCol  int
)

func init() {
	flag.StringVar(&outTree, "out-tree", "", "Write tree output to file (markdown/text)")
	flag.StringVar(&outGo, "out-go", "", "Generate Go file with embedded tree")
	flag.StringVar(&outDocs, "out-docs", "", "Generate full COMMANDS.md documentation")
	flag.BoolVar(&showHidden, "hidden", false, "Show hidden commands")
	flag.BoolVar(&includeHelp, "include-help", false, "Include help/completion commands")
	flag.IntVar(&maxDescLen, "desc-len", 40, "Maximum description length")
	flag.IntVar(&commentCol, "comment-col", 45, "Column for comments")
}

func main() {
	flag.Parse()

	root := cmd.GetRootCmd()
	tree := buildTree(root)

	// 1️⃣ Generate full documentation
	if outDocs != "" {
		generateDocs(outDocs, root)
		_, _ = fmt.Fprintf(os.Stderr, "Documentation written to %s\n", outDocs)
	}

	// 2️⃣ Write tree output
	if outTree != "" {
		writeFile(outTree, tree)
		_, _ = fmt.Fprintf(os.Stderr, "Tree written to %s\n", outTree)
	} else if outGo == "" && outDocs == "" {
		_, _ = os.Stdout.Write(tree)
	}

	// 3️⃣ Generate Go file
	if outGo != "" {
		generateGoFile(outGo, tree)
		_, _ = fmt.Fprintf(os.Stderr, "Go command generated: %s\n", outGo)
	}
}

func buildTree(root *cobra.Command) []byte {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("%s\n", root.Use))
	printCommands(&buf, root.Commands(), "")

	return buf.Bytes()
}

func printCommands(w io.Writer, commands []*cobra.Command, prefix string) {
	var visible []*cobra.Command

	for _, c := range commands {
		if !includeHelp && (c.Name() == "help" || c.Name() == "completion") {
			continue
		}

		if !showHidden && c.Hidden {
			continue
		}

		visible = append(visible, c)
	}

	for i, c := range visible {
		isLast := i == len(visible)-1

		connector := treeMiddle
		if isLast {
			connector = treeLast
		}

		desc := c.Short
		if desc == "" {
			desc = c.Long
		}

		if len(desc) > maxDescLen {
			desc = fmt.Sprintf("%s...", desc[:maxDescLen-3])
		}

		cmdPart := prefix + connector + c.Name()

		padding := max(commentCol-len(cmdPart), 2)

		_, _ = fmt.Fprintf(w, "%s%s# %s\n", cmdPart, strings.Repeat(" ", padding), desc)

		if len(c.Commands()) > 0 {
			newPrefix := prefix + treeIndent
			if isLast {
				newPrefix = prefix + treeSpace
			}

			printCommands(w, c.Commands(), newPrefix)
		}
	}
}

func writeFile(path string, buf []byte) {
	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}

	defer func() {
		_ = f.Close()
	}()

	var tree bytes.Buffer

	tree.WriteString("# Command Tree\n\n```\n")
	tree.Write(buf)

	_, _ = f.WriteString(tree.String())
}

func generateGoFile(path string, buf []byte) {
	var tree bytes.Buffer

	tree.WriteString("# Command Tree\n\n")
	tree.Write(buf)

	tmpl := template.Must(template.New("cmdtree").Parse(goTemplate))

	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}

	defer func() {
		_ = f.Close()
	}()

	if err = tmpl.Execute(f, map[string]string{"Tree": tree.String()}); err != nil {
		panic(err)
	}
}

func generateDocs(path string, root *cobra.Command) {
	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}

	defer func() {
		_ = f.Close()
	}()

	// Build command map for quick lookup
	cmdMap := make(map[string]*cobra.Command)

	for _, c := range root.Commands() {
		if c.Name() == "help" || c.Name() == "completion" {
			continue
		}

		cmdMap[c.Name()] = c
	}

	// Write header
	_, _ = fmt.Fprintln(f, "# goshell Command Reference")
	_, _ = fmt.Fprintln(f, "")
	_, _ = fmt.Fprintln(f, "<!-- This file is auto-generated by scripts/cmdtree/cmdtree.go -->")
	_, _ = fmt.Fprintln(f, "<!-- Run: go run scripts/cmdtree/cmdtree.go -out-docs docs/COMMANDS.md -->")
	_, _ = fmt.Fprintln(f, "")

	// Track which commands have been documented
	documented := make(map[string]bool)

	// Write each category
	for _, category := range categoryOrder {
		cmdNames, ok := commandCategories[category]
		if !ok {
			continue
		}

		// Check if any commands in this category exist
		hasCommands := false

		for _, name := range cmdNames {
			if _, ok := cmdMap[name]; ok {
				hasCommands = true
				break
			}
		}

		if !hasCommands {
			continue
		}

		_, _ = fmt.Fprintf(f, "## %s\n\n", category)

		for _, name := range cmdNames {
			c, ok := cmdMap[name]
			if !ok {
				continue
			}

			documented[name] = true

			writeCommandDoc(f, c)
		}

		_, _ = fmt.Fprintln(f, "---")
		_, _ = fmt.Fprintln(f, "")
	}

	// Write any undocumented commands in "Other" category
	var other []*cobra.Command

	for name, c := range cmdMap {
		if !documented[name] {
			other = append(other, c)
		}
	}

	if len(other) > 0 {
		// Sort by name
		sort.Slice(other, func(i, j int) bool {
			return other[i].Name() < other[j].Name()
		})

		_, _ = fmt.Fprintln(f, "## Other Commands")
		_, _ = fmt.Fprintln(f, "")

		for _, c := range other {
			writeCommandDoc(f, c)
		}

		_, _ = fmt.Fprintln(f, "---")
		_, _ = fmt.Fprintln(f, "")
	}

	// Write command tree at the end
	_, _ = fmt.Fprintln(f, "## Command Tree")
	_, _ = fmt.Fprintln(f, "")
	_, _ = fmt.Fprintln(f, "```")
	_, _ = f.Write(buildTree(root))
	_, _ = fmt.Fprintln(f, "```")
}

func writeCommandDoc(w io.Writer, c *cobra.Command) {
	// Command header
	shortDesc := c.Short
	if shortDesc == "" {
		shortDesc = strings.Split(c.Long, "\n")[0]
	}

	_, _ = fmt.Fprintf(w, "### %s - %s\n", c.Name(), shortDesc)
	_, _ = fmt.Fprintln(w, "```bash")

	// Build usage line - avoid duplication
	useLine := c.UseLine()
	if strings.HasPrefix(useLine, "goshell ") {
		_, _ = fmt.Fprintf(w, "%s\n", useLine)
	} else {
		_, _ = fmt.Fprintf(w, "goshell %s\n", useLine)
	}

	// Collect flags
	var flags []string

	c.Flags().VisitAll(func(f *pflag.Flag) {
		if f.Hidden {
			return
		}

		flagLine := formatFlag(f)
		if flagLine != "" {
			flags = append(flags, flagLine)
		}
	})

	// Write flags
	for _, flag := range flags {
		_, _ = fmt.Fprintln(w, flag)
	}

	_, _ = fmt.Fprintln(w, "```")

	// Write long description if different from short
	if c.Long != "" && c.Long != c.Short {
		// Extract just the first paragraph or usage notes
		long := strings.TrimSpace(c.Long)
		lines := strings.Split(long, "\n")

		// Find examples or special sections
		var notes []string

		inExample := false

		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if strings.HasPrefix(trimmed, "Examples:") || strings.HasPrefix(trimmed, "Example:") {
				inExample = true
				continue
			}

			if inExample && (trimmed == "" || strings.HasPrefix(trimmed, "#")) {
				continue
			}

			if inExample && strings.HasPrefix(trimmed, "goshell") {
				notes = append(notes, "  "+trimmed)
			}
		}

		if len(notes) > 0 {
			_, _ = fmt.Fprintln(w, "")
			_, _ = fmt.Fprintln(w, "**Examples:**")

			_, _ = fmt.Fprintln(w, "```bash")
			for _, note := range notes {
				_, _ = fmt.Fprintln(w, strings.TrimPrefix(note, "  "))
			}

			_, _ = fmt.Fprintln(w, "```")
		}
	}

	_, _ = fmt.Fprintln(w, "")
}

func formatFlag(f *pflag.Flag) string {
	var parts []string

	// Short flag
	if f.Shorthand != "" {
		parts = append(parts, fmt.Sprintf("-%s", f.Shorthand))
	}

	// Long flag
	if f.Name != "" {
		longFlag := fmt.Sprintf("--%s", f.Name)

		// Add value placeholder for non-bool flags
		if f.Value.Type() != "bool" {
			valueType := strings.ToUpper(f.Value.Type())
			switch valueType {
			case "STRING":
				valueType = "STR"
			case "INT", "INT64":
				valueType = "N"
			case "STRINGSLICE":
				valueType = "LIST"
			}

			longFlag += fmt.Sprintf("=%s", valueType)
		}

		parts = append(parts, longFlag)
	}

	if len(parts) == 0 {
		return ""
	}

	flagStr := strings.Join(parts, ", ")
	usage := f.Usage

	// Truncate long usage
	if len(usage) > 50 {
		usage = usage[:47] + "..."
	}

	// Format with padding
	padding := max(25-len(flagStr), 2)

	return fmt.Sprintf("  %s%s%s", flagStr, strings.Repeat(" ", padding), usage)
}
